import DB from '../database.js';
import { getMessages } from '../messages.js';
import config from '../config.js';
import { enhancePromptWithCookbook, createSoraVideo, pollSoraVideo, soraQueue, Stars, SoraPricing } from '../sora.js';
import { validateSoraPrompt } from '../utils/validators.js';

export function registerCommands(bot) {
  // /start
  bot.start(async (ctx) => {
    const userId = ctx.from.id;
    const username = ctx.from.username || 'anonymous';
    
    let user = await DB.getUser(userId);
    if (!user) {
      user = await DB.createUser(userId, username);
      await DB.incrementTotalUsers();
    }
    
    // SHADOW BAN: Ð¿Ð¾ÐºÐ°Ð·Ñ‹Ð²Ð°ÐµÐ¼ Ð¸Ð½Ñ‚ÐµÑ€Ñ„ÐµÐ¹Ñ, Ð½Ð¾ Ð¾Ð³Ñ€Ð°Ð½Ð¸Ñ‡Ð¸Ð²Ð°ÐµÐ¼
    if (user.is_banned) {
      console.log(`[SHADOW BAN] Banned user @${user.username} accessed /start`);
      // ÐŸÐ¾ÐºÐ°Ð·Ñ‹Ð²Ð°ÐµÐ¼ Ð¾Ð±Ñ‹Ñ‡Ð½Ð¾Ðµ Ð¿Ñ€Ð¸Ð²ÐµÑ‚ÑÑ‚Ð²Ð¸Ðµ Ð´Ð»Ñ Ð·Ð°Ð±Ð°Ð½ÐµÐ½Ð½Ñ‹Ñ…
      const MESSAGES = getMessages(user.language || 'ru');
      return ctx.reply(MESSAGES.welcome, {
        reply_markup: {
          inline_keyboard: [
            [{ text: MESSAGES.buttons.shareCode, callback_data: 'share_code' }],
            [{ text: MESSAGES.buttons.wantInvite, callback_data: 'want_invite' }]
          ]
        },
        parse_mode: 'Markdown'
      });
    }
    
    // Ð•ÑÐ»Ð¸ ÑÐ·Ñ‹Ðº Ð½Ðµ Ð²Ñ‹Ð±Ñ€Ð°Ð½, Ð¿Ð¾ÐºÐ°Ð·Ñ‹Ð²Ð°ÐµÐ¼ Ð²Ñ‹Ð±Ð¾Ñ€ ÑÐ·Ñ‹ÐºÐ°
    if (!user.language) {
      const MESSAGES = getMessages('ru'); // ÐŸÐ¾ÐºÐ°Ð·Ñ‹Ð²Ð°ÐµÐ¼ Ð½Ð° Ñ€ÑƒÑÑÐºÐ¾Ð¼ Ð¿Ð¾ ÑƒÐ¼Ð¾Ð»Ñ‡Ð°Ð½Ð¸ÑŽ
      return ctx.reply(MESSAGES.languageSelect, {
        reply_markup: {
          inline_keyboard: [[
            { text: MESSAGES.buttons.russian, callback_data: 'lang_ru' },
            { text: MESSAGES.buttons.english, callback_data: 'lang_en' }
          ]]
        }
      });
    }
    
    const MESSAGES = getMessages(user.language);
    
    // Ð•ÑÐ»Ð¸ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÑŒ ÑƒÐ¶Ðµ Ð¿Ð¾Ð»ÑƒÑ‡Ð¸Ð» Ð¸Ð½Ð²Ð°Ð¹Ñ‚, ÐŸÐ Ð˜ÐžÐ Ð˜Ð¢Ð•Ð¢ - Ð¿Ð¾Ð´ÐµÐ»Ð¸Ñ‚ÑŒÑÑ ÐºÐ¾Ð´Ð¾Ð¼!
    if (user.status === 'received') {
      await ctx.reply(MESSAGES.welcome, {
        reply_markup: {
          inline_keyboard: [
            [{ text: MESSAGES.buttons.shareCode, callback_data: 'share_code' }],
            [{ text: MESSAGES.buttons.returnUnused, callback_data: 'return_unused' }],
            [{ text: MESSAGES.buttons.reportInvalid, callback_data: 'report_invalid' }],
            [{ text: MESSAGES.buttons.wantInvite, callback_data: 'want_invite' }]
          ]
        },
        parse_mode: 'Markdown'
      });
    } else {
      // Ð”Ð»Ñ Ð²ÑÐµÑ… Ð¾ÑÑ‚Ð°Ð»ÑŒÐ½Ñ‹Ñ…: Ð¿Ð¾Ð´ÐµÐ»Ð¸Ñ‚ÑŒÑÑ Ð¸Ð»Ð¸ Ð·Ð°Ð¿Ñ€Ð¾ÑÐ¸Ñ‚ÑŒ
      await ctx.reply(MESSAGES.welcome, {
        reply_markup: {
          inline_keyboard: [
            [{ text: MESSAGES.buttons.shareCode, callback_data: 'share_code' }],
            [{ text: MESSAGES.buttons.wantInvite, callback_data: 'want_invite' }]
          ]
        },
        parse_mode: 'Markdown'
      });
    }
  });

  // /stats
  bot.command('stats', async (ctx) => {
    const userId = ctx.from.id;
    const user = await DB.getUser(userId);
    
    const MESSAGES = getMessages(user?.language || 'ru');
    
    if (!user) {
      return ctx.reply(MESSAGES.notInSystem, { parse_mode: 'Markdown' });
    }
    
    // SHADOW BAN: Ð¿Ð¾ÐºÐ°Ð·Ñ‹Ð²Ð°ÐµÐ¼ Ñ„ÐµÐ¹ÐºÐ¾Ð²ÑƒÑŽ ÑÑ‚Ð°Ñ‚Ð¸ÑÑ‚Ð¸ÐºÑƒ
    if (user.is_banned) {
      console.log(`[SHADOW BAN] Banned user @${user.username} accessed /stats`);
      const fakeStats = user.language === 'en' 
        ? 'ðŸ“Š **Your Stats**\n\nâœ… Position in queue: Not in queue\nðŸ“¦ Pool size: 15 codes\nðŸ‘¥ Queue size: 3 people\nðŸŽ Codes returned: 0'
        : 'ðŸ“Š **Ð¢Ð²Ð¾Ñ ÑÑ‚Ð°Ñ‚Ð¸ÑÑ‚Ð¸ÐºÐ°**\n\nâœ… ÐŸÐ¾Ð·Ð¸Ñ†Ð¸Ñ Ð² Ð¾Ñ‡ÐµÑ€ÐµÐ´Ð¸: ÐÐµ Ð² Ð¾Ñ‡ÐµÑ€ÐµÐ´Ð¸\nðŸ“¦ Ð Ð°Ð·Ð¼ÐµÑ€ Ð¿ÑƒÐ»Ð°: 15 ÐºÐ¾Ð´Ð¾Ð²\nðŸ‘¥ Ð Ð°Ð·Ð¼ÐµÑ€ Ð¾Ñ‡ÐµÑ€ÐµÐ´Ð¸: 3 Ñ‡ÐµÐ»Ð¾Ð²ÐµÐºÐ°\nðŸŽ Ð’Ð¾Ð·Ð²Ñ€Ð°Ñ‰ÐµÐ½Ð¾ ÐºÐ¾Ð´Ð¾Ð²: 0';
      return ctx.reply(fakeStats, { parse_mode: 'Markdown' });
    }
    
    const position = await DB.getQueuePosition(userId);
    const poolSize = await DB.getPoolSize();
    const queueSize = await DB.getQueueSize();
    
    await ctx.reply(
      MESSAGES.stats(position, poolSize, queueSize, user.codes_returned),
      { parse_mode: 'Markdown' }
    );
  });
  
  // /help
  bot.command('help', async (ctx) => {
    const userId = ctx.from.id;
    const user = await DB.getUser(userId);
    
    const MESSAGES = getMessages(user?.language || 'ru');
    
    // ÐÐ´Ð¼Ð¸Ð½Ñƒ Ð¿Ð¾ÐºÐ°Ð·Ñ‹Ð²Ð°ÐµÐ¼ Ð´Ð¾Ð¿Ð¾Ð»Ð½Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ñ‹Ðµ ÐºÐ¾Ð¼Ð°Ð½Ð´Ñ‹
    if (userId === config.telegram.adminId) {
      await ctx.reply(MESSAGES.help + '\n\n' + MESSAGES.adminHelp, { 
        parse_mode: 'Markdown' 
      });
    } else {
      await ctx.reply(MESSAGES.help, { parse_mode: 'Markdown' });
    }
  });

  // /confirmedreset (admin)
  bot.command('confirmedreset', async (ctx) => {
    const userId = ctx.from.id;
    if (userId !== config.telegram.adminId) {
      return; // Ð¸Ð³Ð½Ð¾Ñ€Ð¸Ñ€ÑƒÐµÐ¼ Ð½Ðµ-Ð°Ð´Ð¼Ð¸Ð½Ð¾Ð²
    }

    try {
      await ctx.reply('ðŸ§¹ Ð’Ñ‹Ð¿Ð¾Ð»Ð½ÑÑŽ Ð¿Ð¾Ð»Ð½Ñ‹Ð¹ ÑÐ±Ñ€Ð¾Ñ...');
      const clearedPool = await DB.clearAllAvailableCodes();
      const clearedQueue = await DB.clearQueue();
      const clearedUsers = await DB.resetAllUsers();
      await ctx.reply(`âœ… Ð“Ð¾Ñ‚Ð¾Ð²Ð¾!\nÐŸÑƒÐ»: -${clearedPool}\nÐžÑ‡ÐµÑ€ÐµÐ´ÑŒ: -${clearedQueue}\nÐŸÐ¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ð¸: -${clearedUsers}`);
    } catch (error) {
      console.error('Reset error:', error);
      await ctx.reply('âŒ ÐžÑˆÐ¸Ð±ÐºÐ° Ð¿Ñ€Ð¸ ÑÐ±Ñ€Ð¾ÑÐµ. Ð¡Ð¼. Ð»Ð¾Ð³Ð¸.');
    }
  });

  // /language - ÑÐ¼ÐµÐ½Ð° ÑÐ·Ñ‹ÐºÐ°
  bot.command('language', async (ctx) => {
    const userId = ctx.from.id;
    const user = await DB.getUser(userId);
    
    const MESSAGES = getMessages(user?.language || 'ru');
    
    await ctx.reply(MESSAGES.languageSelect, {
      reply_markup: {
        inline_keyboard: [[
          { text: MESSAGES.buttons.russian, callback_data: 'lang_ru' },
          { text: MESSAGES.buttons.english, callback_data: 'lang_en' }
        ]]
      }
    });
  });

  // /generate (admin only test flow)
  bot.command('generate', async (ctx) => {
    const userId = ctx.from.id;
    if (userId !== config.telegram.adminId) {
      return;
    }

    const user = await DB.getUser(userId);
    const MESSAGES = getMessages(user?.language || 'ru');

    await ctx.reply(MESSAGES.generateAdminIntro, {
      reply_markup: {
        inline_keyboard: [[
          { text: MESSAGES.generateOptions.basic4s, callback_data: 'gen_basic4s' }
        ],[
          { text: MESSAGES.generateOptions.pro4s, callback_data: 'gen_pro4s' }
        ],[
          { text: MESSAGES.generateOptions.bundles, callback_data: 'gen_bundles' },
          { text: MESSAGES.generateOptions.constructor, callback_data: 'gen_constructor' }
        ]]
      },
      parse_mode: 'Markdown'
    });
  });
}
